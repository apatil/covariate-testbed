#!/usr/bin/python

# Author: Anand Patil
# Date: 6 Feb 2009
# License: Creative Commons BY-NC-SA
####################################

# TODO: Move into map_utils, make generic.

import sys

doc_str = doc_str = """
How to use cov-test-predict

cov-test-predict dbname input.csv ntot burn

- dbname: The filename used for the trace.
- input.csv: A csv file whose column names are lat, lon, t, pos, neg and the names of any covariates used.
- ntot: The total number of predictions to make.
- burn: The number of burnin iterations to discard.

Produces:
- dbname_holdout_obs.csv : A csv file whose rows contain the longitude, latitude, time and converted value of 'p' at each holdout location
- dbname_samps.csv : A csv file whose rows contain ntot predictive samples of 'p' at each holdout location

The i'th element of the 'p' column of dbname_holdout_obs.csv can be compared with the i'th row in dbname_samps.csv.
"""

if len(sys.argv)!=5:
    print doc_str
    sys.exit()
if sys.argv[1] in ['-h','--help']:
    print doc_str
    sys.exit()


from cov_test import trace_to_prediction
import numpy as np
from pylab import csv2rec, rec2csv

# trace_to_prediction(tracefile, lon, lat, t, covariate_values, ntot, burn=0)

def maybe_int(str, n):
    try:
        return int(str)
    except ValueError:
        print 'Failed to convert value %s given for argument %s to integer.'%(str,n)
        sys.exit()

tracefile = sys.argv[1]
input = sys.argv[2]
ntot = maybe_int(sys.argv[3],'ntot')
burn = maybe_int(sys.argv[4],'n')

input = csv2rec(input)
lon = input.lon
lat = input.lat
t = input.t
pos = input.pos
neg = input.neg

cv = {}
for n in input.dtype.names:
    if n not in ['lon','lat','pos','neg']:
        cv[n]=input[n]

samps = trace_to_prediction(tracefile, lon, lat, t, cv, ntot, burn=0)
samps.tofile(tracefile.replace('.hdf5','')+'_samps.csv',sep=',')
p_pred_data = np.rec.fromarrays(((pos+1.)/(pos+neg+2.), lon, lat, t), names=['p','lon','lat','t'])
rec2csv(p_pred_data,tracefile.replace('.hdf5','')+'_holdout_obs.csv')
